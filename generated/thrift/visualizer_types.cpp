/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "visualizer_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




Location::~Location() throw() {
}


void Location::__set_x(const int32_t val) {
  this->x = val;
}

void Location::__set_y(const int32_t val) {
  this->y = val;
}
std::ostream& operator<<(std::ostream& out, const Location& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Location::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_x = false;
  bool isset_y = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->x);
          isset_x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->y);
          isset_y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_x)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_y)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Location::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Location");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Location &a, Location &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
}

Location::Location(const Location& other0) {
  x = other0.x;
  y = other0.y;
}
Location& Location::operator=(const Location& other1) {
  x = other1.x;
  y = other1.y;
  return *this;
}
void Location::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Location(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ")";
}


Iteration::~Iteration() throw() {
}


void Iteration::__set_clearPrevious(const bool val) {
  this->clearPrevious = val;
}

void Iteration::__set_agentLocation(const Location& val) {
  this->agentLocation = val;
}

void Iteration::__set_newEnvelopeNodesCells(const std::set<Location> & val) {
  this->newEnvelopeNodesCells = val;
}

void Iteration::__set_projectedPath(const std::set<Location> & val) {
  this->projectedPath = val;
__isset.projectedPath = true;
}
std::ostream& operator<<(std::ostream& out, const Iteration& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Iteration::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_clearPrevious = false;
  bool isset_agentLocation = false;
  bool isset_newEnvelopeNodesCells = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->clearPrevious);
          isset_clearPrevious = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->agentLocation.read(iprot);
          isset_agentLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->newEnvelopeNodesCells.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readSetBegin(_etype5, _size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              Location _elem7;
              xfer += _elem7.read(iprot);
              this->newEnvelopeNodesCells.insert(_elem7);
            }
            xfer += iprot->readSetEnd();
          }
          isset_newEnvelopeNodesCells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->projectedPath.clear();
            uint32_t _size8;
            ::apache::thrift::protocol::TType _etype11;
            xfer += iprot->readSetBegin(_etype11, _size8);
            uint32_t _i12;
            for (_i12 = 0; _i12 < _size8; ++_i12)
            {
              Location _elem13;
              xfer += _elem13.read(iprot);
              this->projectedPath.insert(_elem13);
            }
            xfer += iprot->readSetEnd();
          }
          this->__isset.projectedPath = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_clearPrevious)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_agentLocation)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_newEnvelopeNodesCells)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Iteration::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Iteration");

  xfer += oprot->writeFieldBegin("clearPrevious", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->clearPrevious);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("agentLocation", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->agentLocation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("newEnvelopeNodesCells", ::apache::thrift::protocol::T_SET, 3);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->newEnvelopeNodesCells.size()));
    std::set<Location> ::const_iterator _iter14;
    for (_iter14 = this->newEnvelopeNodesCells.begin(); _iter14 != this->newEnvelopeNodesCells.end(); ++_iter14)
    {
      xfer += (*_iter14).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.projectedPath) {
    xfer += oprot->writeFieldBegin("projectedPath", ::apache::thrift::protocol::T_SET, 4);
    {
      xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->projectedPath.size()));
      std::set<Location> ::const_iterator _iter15;
      for (_iter15 = this->projectedPath.begin(); _iter15 != this->projectedPath.end(); ++_iter15)
      {
        xfer += (*_iter15).write(oprot);
      }
      xfer += oprot->writeSetEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Iteration &a, Iteration &b) {
  using ::std::swap;
  swap(a.clearPrevious, b.clearPrevious);
  swap(a.agentLocation, b.agentLocation);
  swap(a.newEnvelopeNodesCells, b.newEnvelopeNodesCells);
  swap(a.projectedPath, b.projectedPath);
  swap(a.__isset, b.__isset);
}

Iteration::Iteration(const Iteration& other16) {
  clearPrevious = other16.clearPrevious;
  agentLocation = other16.agentLocation;
  newEnvelopeNodesCells = other16.newEnvelopeNodesCells;
  projectedPath = other16.projectedPath;
  __isset = other16.__isset;
}
Iteration& Iteration::operator=(const Iteration& other17) {
  clearPrevious = other17.clearPrevious;
  agentLocation = other17.agentLocation;
  newEnvelopeNodesCells = other17.newEnvelopeNodesCells;
  projectedPath = other17.projectedPath;
  __isset = other17.__isset;
  return *this;
}
void Iteration::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Iteration(";
  out << "clearPrevious=" << to_string(clearPrevious);
  out << ", " << "agentLocation=" << to_string(agentLocation);
  out << ", " << "newEnvelopeNodesCells=" << to_string(newEnvelopeNodesCells);
  out << ", " << "projectedPath="; (__isset.projectedPath ? (out << to_string(projectedPath)) : (out << "<null>"));
  out << ")";
}


IterationBundle::~IterationBundle() throw() {
}


void IterationBundle::__set_iterations(const std::vector<Iteration> & val) {
  this->iterations = val;
}

void IterationBundle::__set_bufferIsFlushed(const bool val) {
  this->bufferIsFlushed = val;
}
std::ostream& operator<<(std::ostream& out, const IterationBundle& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t IterationBundle::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_iterations = false;
  bool isset_bufferIsFlushed = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->iterations.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _etype21;
            xfer += iprot->readListBegin(_etype21, _size18);
            this->iterations.resize(_size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              xfer += this->iterations[_i22].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_iterations = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->bufferIsFlushed);
          isset_bufferIsFlushed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_iterations)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bufferIsFlushed)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t IterationBundle::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IterationBundle");

  xfer += oprot->writeFieldBegin("iterations", ::apache::thrift::protocol::T_LIST, 1);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->iterations.size()));
    std::vector<Iteration> ::const_iterator _iter23;
    for (_iter23 = this->iterations.begin(); _iter23 != this->iterations.end(); ++_iter23)
    {
      xfer += (*_iter23).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bufferIsFlushed", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->bufferIsFlushed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IterationBundle &a, IterationBundle &b) {
  using ::std::swap;
  swap(a.iterations, b.iterations);
  swap(a.bufferIsFlushed, b.bufferIsFlushed);
}

IterationBundle::IterationBundle(const IterationBundle& other24) {
  iterations = other24.iterations;
  bufferIsFlushed = other24.bufferIsFlushed;
}
IterationBundle& IterationBundle::operator=(const IterationBundle& other25) {
  iterations = other25.iterations;
  bufferIsFlushed = other25.bufferIsFlushed;
  return *this;
}
void IterationBundle::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IterationBundle(";
  out << "iterations=" << to_string(iterations);
  out << ", " << "bufferIsFlushed=" << to_string(bufferIsFlushed);
  out << ")";
}


Init::~Init() throw() {
}


void Init::__set_width(const int32_t val) {
  this->width = val;
}

void Init::__set_height(const int32_t val) {
  this->height = val;
}

void Init::__set_start(const Location& val) {
  this->start = val;
}

void Init::__set_goals(const std::vector<Location> & val) {
  this->goals = val;
}

void Init::__set_blockedCells(const std::set<Location> & val) {
  this->blockedCells = val;
}
std::ostream& operator<<(std::ostream& out, const Init& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Init::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_width = false;
  bool isset_height = false;
  bool isset_start = false;
  bool isset_goals = false;
  bool isset_blockedCells = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          isset_width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          isset_height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->start.read(iprot);
          isset_start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->goals.clear();
            uint32_t _size26;
            ::apache::thrift::protocol::TType _etype29;
            xfer += iprot->readListBegin(_etype29, _size26);
            this->goals.resize(_size26);
            uint32_t _i30;
            for (_i30 = 0; _i30 < _size26; ++_i30)
            {
              xfer += this->goals[_i30].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_goals = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_SET) {
          {
            this->blockedCells.clear();
            uint32_t _size31;
            ::apache::thrift::protocol::TType _etype34;
            xfer += iprot->readSetBegin(_etype34, _size31);
            uint32_t _i35;
            for (_i35 = 0; _i35 < _size31; ++_i35)
            {
              Location _elem36;
              xfer += _elem36.read(iprot);
              this->blockedCells.insert(_elem36);
            }
            xfer += iprot->readSetEnd();
          }
          isset_blockedCells = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_width)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_height)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_start)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_goals)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_blockedCells)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Init::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Init");

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->start.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("goals", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->goals.size()));
    std::vector<Location> ::const_iterator _iter37;
    for (_iter37 = this->goals.begin(); _iter37 != this->goals.end(); ++_iter37)
    {
      xfer += (*_iter37).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blockedCells", ::apache::thrift::protocol::T_SET, 5);
  {
    xfer += oprot->writeSetBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->blockedCells.size()));
    std::set<Location> ::const_iterator _iter38;
    for (_iter38 = this->blockedCells.begin(); _iter38 != this->blockedCells.end(); ++_iter38)
    {
      xfer += (*_iter38).write(oprot);
    }
    xfer += oprot->writeSetEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Init &a, Init &b) {
  using ::std::swap;
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.start, b.start);
  swap(a.goals, b.goals);
  swap(a.blockedCells, b.blockedCells);
}

Init::Init(const Init& other39) {
  width = other39.width;
  height = other39.height;
  start = other39.start;
  goals = other39.goals;
  blockedCells = other39.blockedCells;
}
Init& Init::operator=(const Init& other40) {
  width = other40.width;
  height = other40.height;
  start = other40.start;
  goals = other40.goals;
  blockedCells = other40.blockedCells;
  return *this;
}
void Init::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Init(";
  out << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "start=" << to_string(start);
  out << ", " << "goals=" << to_string(goals);
  out << ", " << "blockedCells=" << to_string(blockedCells);
  out << ")";
}


NoDataException::~NoDataException() throw() {
}

std::ostream& operator<<(std::ostream& out, const NoDataException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t NoDataException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NoDataException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NoDataException");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NoDataException &a, NoDataException &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

NoDataException::NoDataException(const NoDataException& other41) : TException() {
  (void) other41;
}
NoDataException& NoDataException::operator=(const NoDataException& other42) {
  (void) other42;
  return *this;
}
void NoDataException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NoDataException(";
  out << ")";
}

const char* NoDataException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: NoDataException";
  }
}


