/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef visualizer_TYPES_H
#define visualizer_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/stdcxx.h>




class Location;

class Iteration;

class IterationBundle;

class Init;

class NoDataException;


class Location : public virtual ::apache::thrift::TBase {
 public:

  Location(const Location&);
  Location& operator=(const Location&);
  Location() : x(0), y(0) {
  }

  virtual ~Location() throw();
  int32_t x;
  int32_t y;

  void __set_x(const int32_t val);

  void __set_y(const int32_t val);

  bool operator == (const Location & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    return true;
  }
  bool operator != (const Location &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Location & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Location &a, Location &b);

std::ostream& operator<<(std::ostream& out, const Location& obj);

typedef struct _Iteration__isset {
  _Iteration__isset() : projectedPath(false) {}
  bool projectedPath :1;
} _Iteration__isset;

class Iteration : public virtual ::apache::thrift::TBase {
 public:

  Iteration(const Iteration&);
  Iteration& operator=(const Iteration&);
  Iteration() : clearPrevious(0) {
  }

  virtual ~Iteration() throw();
  bool clearPrevious;
  Location agentLocation;
  std::set<Location>  newEnvelopeNodesCells;
  std::set<Location>  projectedPath;

  _Iteration__isset __isset;

  void __set_clearPrevious(const bool val);

  void __set_agentLocation(const Location& val);

  void __set_newEnvelopeNodesCells(const std::set<Location> & val);

  void __set_projectedPath(const std::set<Location> & val);

  bool operator == (const Iteration & rhs) const
  {
    if (!(clearPrevious == rhs.clearPrevious))
      return false;
    if (!(agentLocation == rhs.agentLocation))
      return false;
    if (!(newEnvelopeNodesCells == rhs.newEnvelopeNodesCells))
      return false;
    if (__isset.projectedPath != rhs.__isset.projectedPath)
      return false;
    else if (__isset.projectedPath && !(projectedPath == rhs.projectedPath))
      return false;
    return true;
  }
  bool operator != (const Iteration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Iteration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Iteration &a, Iteration &b);

std::ostream& operator<<(std::ostream& out, const Iteration& obj);


class IterationBundle : public virtual ::apache::thrift::TBase {
 public:

  IterationBundle(const IterationBundle&);
  IterationBundle& operator=(const IterationBundle&);
  IterationBundle() : bufferIsFlushed(0) {
  }

  virtual ~IterationBundle() throw();
  std::vector<Iteration>  iterations;
  bool bufferIsFlushed;

  void __set_iterations(const std::vector<Iteration> & val);

  void __set_bufferIsFlushed(const bool val);

  bool operator == (const IterationBundle & rhs) const
  {
    if (!(iterations == rhs.iterations))
      return false;
    if (!(bufferIsFlushed == rhs.bufferIsFlushed))
      return false;
    return true;
  }
  bool operator != (const IterationBundle &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IterationBundle & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IterationBundle &a, IterationBundle &b);

std::ostream& operator<<(std::ostream& out, const IterationBundle& obj);


class Init : public virtual ::apache::thrift::TBase {
 public:

  Init(const Init&);
  Init& operator=(const Init&);
  Init() : width(0), height(0) {
  }

  virtual ~Init() throw();
  int32_t width;
  int32_t height;
  Location start;
  std::vector<Location>  goals;
  std::set<Location>  blockedCells;

  void __set_width(const int32_t val);

  void __set_height(const int32_t val);

  void __set_start(const Location& val);

  void __set_goals(const std::vector<Location> & val);

  void __set_blockedCells(const std::set<Location> & val);

  bool operator == (const Init & rhs) const
  {
    if (!(width == rhs.width))
      return false;
    if (!(height == rhs.height))
      return false;
    if (!(start == rhs.start))
      return false;
    if (!(goals == rhs.goals))
      return false;
    if (!(blockedCells == rhs.blockedCells))
      return false;
    return true;
  }
  bool operator != (const Init &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Init & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Init &a, Init &b);

std::ostream& operator<<(std::ostream& out, const Init& obj);


class NoDataException : public ::apache::thrift::TException {
 public:

  NoDataException(const NoDataException&);
  NoDataException& operator=(const NoDataException&);
  NoDataException() {
  }

  virtual ~NoDataException() throw();

  bool operator == (const NoDataException & /* rhs */) const
  {
    return true;
  }
  bool operator != (const NoDataException &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NoDataException & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(NoDataException &a, NoDataException &b);

std::ostream& operator<<(std::ostream& out, const NoDataException& obj);



#endif
